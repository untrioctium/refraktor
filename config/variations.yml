# Variation definitions
# Code in this file is adapted from flam3 by Scott Draves and others
# https://github.com/scottdraves/flam3/blob/master/variations.c

xcommon:
    sumsq: px * px + py * py
    sqrt: hypot(px, py)
    atan: atan2(px, py)
    phi: atan2(py, px)
    sina: px / xcommon(sqrt)
    cosa: py / xcommon(sqrt)
    sinr: sin(xcommon(sqrt))
    cosr: cos(xcommon(sqrt))
    
variations:
    linear: |-
        nx += weight * px;
        ny += weight * py;
            
    sinusoidal: |-
        nx += weight * sin(px);
        ny += weight * sin(py);
        
    spherical: |-
        Real r2 = weight / ( xcommon(sumsq) + M_EPS);
        nx += r2 * px;
        ny += r2 * py;
        
    swirl: |-
        Real c1 = sin(xcommon(sumsq));
        Real c2 = cos(xcommon(sumsq));
        nx += weight * (c1 * px - c2 * py);
        ny += weight * (c2 * px + c1 * py);
        
    horseshoe: |-
        weight /= (xcommon(sqrt) + M_EPS);
        nx += weight * (px + py) * (px - py);
        ny += weight * Real(2.0) * px * py;
        
    polar: |-
        nx += weight * xcommon(atan) / M_PI;
        ny += weight * (xcommon(sqrt) - Real(1.0));
        
    handkerchief: |-
        weight *= xcommon(sqrt);
        nx += weight * sin(xcommon(atan) + xcommon(sqrt));
        ny += weight * cos(xcommon(atan) - xcommon(sqrt));
        
    heart: |-
        Real a = xcommon(sqrt) * xcommon(atan);
        Real ca,sa;
        Real r = weight * xcommon(sqrt);

        sincos(a,&sa,&ca);

        nx += r * sa;
        ny += (-r) * ca;

    disc: |-
        Real a = xcommon(atan) * M_1_PI;
        Real r = M_PI * xcommon(sqrt);
        Real sr,cr;
        sincos(r,&sr,&cr);

        nx += weight * sr * a;
        ny += weight * cr * a;
        
    spiral: |-
        Real r = xcommon(sqrt) + M_EPS;
        Real coef = weight / r;
        Real sr, cr;
        sincos(r, &sr, &cr);
        nx += coef * (xcommon(cosa) + sr);
        ny += coef * (xcommon(sina) - cr);
        
    hyperbolic: |-
        Real coeff = xcommon(sqrt) + M_EPS;
        nx += weight * xcommon(sina) / coeff;
        ny += weight * xcommon(cosa) * coeff;
        
    diamond: |-
        Real sr,cr;
        sincos( xcommon(sqrt), &sr, &cr);
        nx += weight * xcommon(sina) * cr;
        ny += weight * xcommon(cosa) * sr;
        
    ex: |-
        Real n0 = sin(xcommon(atan) + xcommon(sqrt));
        Real n1 = cos(xcommon(atan) - xcommon(sqrt));
        Real m0 = n0 * n0 * n0 * xcommon(sqrt);
        Real m1 = n1 * n1 * n1 * xcommon(sqrt);
        nx += weight * (m0 + m1);
        ny += weight * (m0 - m1);

    julia: |-
        Real r;
        Real a = 0.5 * xcommon(atan);
        Real sa,ca;

        a += M_PI * (rs->rand() & 1);

        r = weight * sqrt(xcommon(sqrt));

        sincos(a,&sa,&ca);

        nx += r * ca;
        ny += r * sa;
        
    bent: |-
        Real nx = px;
        Real ny = py;
        if(nx < Real(0.0)) nx *= Real(2.0);
        if(ny < Real(0.0)) ny /= Real(2.0);
        nx += weight * nx;
        ny += weight * ny;
        
    waves: |-
        nx += weight * (px + xaffine_b * sin( py / (xaffine_c * xaffine_c + M_EPS)));
        ny += weight * (py + xaffine_e * sin( px / (xaffine_f * xaffine_f + M_EPS)));
        
    fisheye: |-
        weight *= 2 / (xcommon(sqrt) + 1);
        nx += weight * py;
        ny += weight * px;
    
    popcorn: |-
        nx += weight * (px + xaffine_c * sin(tan(3 * py)));
        ny += weight * (py + xaffine_f * sin(tan(3 * px)));
        
    exponential: |-
        Real dx = weight * exp(px - 1.0);
        Real sdy, cdy;
        sincos( M_PI * py, &sdy, &cdy );
        nx += dx * cdy;
        ny += dx * sdy;
        
    power: |-
        Real coef = weight * pow(xcommon(sqrt), xcommon(sina));
        nx += coef * xcommon(cosa);
        ny += coef * xcommon(sina);
        
    cosine: |-
        Real sa, ca;
        sincos( px * M_PI, &sa, &ca );
        nx += weight * (ca * cosh(py));
        ny += weight * (-sa * sinh(py));
        
    rings: |-
        Real dx = xaffine_c * xaffine_c + M_EPS;
        weight *= (fmod(xcommon(sqrt) + dx, 2 * dx) - dx + xcommon(sqrt) * (1 - dx));
        nx += weight * xcommon(cosa);
        ny += weight * xcommon(sina);
        
    fan: |-
        Real dx = M_PI * (xaffine_c * xaffine_c + M_EPS);
        Real dx2 = 0.5f * dx;
        Real a = xcommon(atan);
        weight *= xcommon(sqrt);
        Real sa, ca;
        a += (fmod(a + xaffine_f, dx) > dx2) ? -dx2: dx2;
        __sincos(a, &sa, &ca);
        nx += weight * ca;
        ny += weight * sa;

    blob:
        param:
            blob_low: {}
            blob_high: 
                default: 1.0
            blob_waves: 
                default: 1.0
        src: |-
            Real bdiff = blob_high - blob_low;
            weight *= xcommon(sqrt) * (blob_low + bdiff * (0.5f + 0.5f * sin(blob_waves * xcommon(atan))));
            nx += weight * xcommon(sina);
            ny += weight * xcommon(cosa);

    pdj:
        param:
            pdj_a: {}
            pdj_b: {}
            pdj_c: {}
            pdj_d: {}
        src: |-
            nx += weight * (sin(pdj_a * py) - cos(pdj_b * px));
            ny += weight * (sin(pdj_c * px) - cos(pdj_d * py));
            
    fan2:
        param:
            fan2_x: {}
            fan2_y: {}
        src: |-
            Real dy = fan2_y;
            Real dx = M_PI * (fan2_x * fan2_x + M_EPS);
            Real dx2 = 0.5 * dx;
            Real a = xcommon(atan);
            Real sa,ca;
            Real r = weight * xcommon(sqrt);
            Real t = a + dy - dx * (int)((a + dy)/dx);
            if (t>dx2)
               a = a-dx2;
            else
               a = a+dx2;
            sincos(a,&sa,&ca);
            nx += r * sa;
            ny += r * ca;
            
    rings2: 
        param:
            rings2_val: {}
        src: |-
            Real r = xcommon(sqrt);
            Real dx = rings2_val * rings2_val + M_EPS;
            r += -2.0f * dx * (int)((r+dx)/(2.0f * dx)) + r * (1.0f-dx);
            nx += weight * xcommon(sina) * r;
            ny += weight * xcommon(cosa) * r;
            
    eyefish: |-
        Real coef = 2 * weight / (xcommon(sqrt) + 1);
        nx += coef * px;
        ny += coef * py;

    bubble: |-
        Real coef = weight / (Real(0.25) * xcommon(sumsq) + 1);
        nx += coef * px;
        ny += coef * py;

    cylinder: |-
        nx += weight * sin(px);
        ny += weight * py;      

    perspective:
        param:
            perspective_angle: {}
            perspective_dist: {}
        src: |-
            Real vsin, vfcos;
            sincos(perspective_angle * M_PI/ 2.0, &vsin, &vfcos);
            vfcos *= perspective_dist;
            Real t= 1.0 / (perspective_dist - py * vsin);
            nx += weight * perspective_dist * px * t;
            ny += weight * vfcos * py * t;

    noise: |-
        Real sr, cr, r;
        sincos(rs->rand_uniform() * 2.0f * M_PI, &sr, &cr);
        r = weight * rs->rand_uniform();
        nx += px * r * sr;
        ny += py * r * cr;

    julian:
        param:
            julian_dist: 
                default: 1.0
            julian_power: 
                default: 1.0
        src: |-
            Real julian_rn = abs(julian_power);
            Real julian_cn = julian_dist/julian_power/2.0;
            int t_rnd = trunc(julian_rn * rs->rand_uniform());
            Real tmpr = (xcommon(phi) + 2 * M_PI * t_rnd) / julian_power;
            Real r = weight * __pow(xcommon(sumsq), julian_cn);
            Real sa, ca;
            __sincos(tmpr, &sa, &ca);
            nx += r * ca;
            ny += r * sa; 

    juliascope:
        param:
            juliascope_dist: 
                default: 1.0
            juliascope_power: 
                default: 1.0
        src: |-
            Real juliascope_rn = abs(juliascope_power);
            Real juliascope_cn = juliascope_dist / juliascope_power;
            int t_rnd = trunc(juliascope_rn * rs->rand_uniform());
            Real tmpr, r;
            Real sa,ca;
            if((t_rnd & 1) == 0)
                tmpr = (2 * M_PI * t_rnd + xcommon(phi)) / juliascope_power;
            else
                tmpr = (2 * M_PI * t_rnd - xcommon(phi)) / juliascope_power;
            sincos(tmpr, &sa, &ca);
            r = weight * pow(xcommon(sqrt), juliascope_cn);
            nx += r * ca;
            ny += r * sa;

    blur: |-
        Real r, sinang,cosang;
        sincos( rs->rand_uniform() * 2 * M_PI, &sinang, &cosang );
        r = weight * rs->rand_uniform(); 
        nx += r * cosang;
        ny += r * sinang;  

    gaussian_blur: |-
        Real r, sinang,cosang;
        sincos( rs->rand_uniform() * 2 * M_PI, &sinang, &cosang );
        r = weight * (rs->rand_uniform() + rs->rand_uniform() + rs->rand_uniform() + rs->rand_uniform() - 2.0);
        nx += r * cosang;
        ny += r * sinang;     

    radial_blur:
        param:
            radial_blur_angle: {}
        src: |-
            Real spinvar,zoomvar, rnd_g, rz, tmpa, sa, ca;
            sincos(radial_blur_angle * M_PI / Real(2.0), &spinvar, &zoomvar);
            rnd_g = weight *(rs->rand_uniform() + rs->rand_uniform() +rs->rand_uniform() +rs->rand_uniform() - 2.0);
            tmpa = xcommon(phi) + spinvar * rnd_g;
            sincos(tmpa, &sa, &ca);
            rz = zoomvar * rnd_g - 1;
            nx += xcommon(sqrt) * ca + rz * px;
            ny += xcommon(sqrt) * sa + rz * py;     

    pie:
        param:
            pie_thickness: {}
            pie_rotation: {}
            pie_slices: 
                default: 6.0
        src: |-
            Real a, r, sa, ca;
            int sl;
            sl = (int) (rs->rand_uniform() * pie_slices + 0.5f);
            a = pie_rotation + 2.0f * M_PI * (sl + rs->rand_uniform() * pie_thickness)/pie_slices;
            r = weight * rs->rand_uniform();
            sincos(a, &sa, &ca);
            nx += r * ca;
            ny += r * sa;

    ngon:
        param:
            ngon_power: {}
            ngon_sides: {}
            ngon_circle: {}
            ngon_corners: {}
        src: |-
            Real r_factor,theta,phi,b, amp;
            r_factor = pow(xcommon(sumsq), Real(ngon_power/2.0));
            theta = xcommon(phi);
            b = 2*M_PI/ngon_sides;
            phi = theta - (b*floor(theta/b));
            if (phi > b/2)
                phi -= b;
            amp = ngon_corners * (1.0 / (cos(phi) + M_EPS) - 1.0) + ngon_circle;
            amp /= (r_factor + M_EPS);
            nx += weight * px * amp;
            ny += weight * py * amp;
     
    curl:
        param:
            curl_c1: 
                default: 1.0
            curl_c2: {}
        src: |-
            Real re = 1.0 + curl_c1 * px + curl_c2 * (px * px - py * py);
            Real im = curl_c1 * py + 2.0 * curl_c2 * px * py;
            Real r = weight / (re * re + im * im);
            nx += (px * re + py * im) * r;
            ny += (py * re - px * im) * r;

    rectangles:
        param:
            rectangles_x: 
                default: 1.0
            rectangles_y: 
                default: 1.0
        src: |-
            if(rectangles_x == Real(0.0))
                nx += weight * px;
            else
                nx += weight * ((2 * floor(px / rectangles_x) + 1) * rectangles_x - px);
            if(rectangles_y == Real(0.0))
                ny += weight * py;
            else
                ny += weight * ((2 * floor(py / rectangles_y) + 1) * rectangles_y - py);

    arch: |-
        Real ang = rs->rand_uniform() * weight * M_PI;
        Real sinr,cosr;
        sincos(ang,&sinr,&cosr);

        nx += weight * sinr;
        ny += weight * (sinr*sinr)/cosr;
        
    tangent: |-
        nx += weight * sin(px)/cos(py);
        ny += weight * tan(py);
        
    square: |-
        nx += weight * (rs->rand_uniform() - 0.5);
        ny += weight * (rs->rand_uniform() - 0.5);
        
    rays: |-
        Real ang = weight * rs->rand_uniform() * M_PI;
        Real r = weight / (xcommon(sumsq) + M_EPS);
        Real tanr = weight * tan(ang) * r;
        nx += tanr * cos(px);
        ny += tanr * sin(py);
        
    blade: |-
        Real r = rs->rand_uniform() * weight * xcommon(sqrt);
        Real sinr,cosr;
        sincos(r,&sinr,&cosr);
        nx += weight * px * (cosr + sinr);
        ny += weight * px * (cosr - sinr);
        
    secant2: |-
        Real r = weight * xcommon(sqrt);
        Real cr = cos(r);
        Real icr = 1.0/cr;
        nx += weight * px;
        if (cr<0)
          ny += weight*(icr + 1);
        else
          ny += weight*(icr - 1);
          
    twintrian:
        Real r = rs->rand_uniform() * weight * xcommon(sqrt);
        Real sinr,cosr,diff;
        sincos(r,&sinr,&cosr);
        diff = log10(sinr*sinr)+cosr;
        if (badvalue(diff))
            diff = -30.0;
        nx += weight * px * diff;
        ny += weight * px * (diff - sinr*M_PI);
        
    cross: |-
        Real s = px * px - py * py;
        weight *= sqrt(1.0f/(s * s + M_EPS));
        nx += px * weight;
        ny += py * weight;

    disc2:
        param:
            disc2_rot: {}
            disc2_twist: {}
        src: |-
            Real add = disc2_twist;
            Real k, disc2_timespi, disc2_sinadd, disc2_cosadd;

            disc2_timespi = disc2_rot * M_PI;

            sincos(add,&disc2_sinadd,&disc2_cosadd);
            disc2_cosadd -= 1;

            if (add > 2 * M_PI) {
              k = (1 + add - 2*M_PI);
              disc2_cosadd *= k;
              disc2_sinadd *= k;
            }

            if (add < -2 * M_PI) {
              k = (1 + add + 2*M_PI);
              disc2_cosadd *= k;
              disc2_sinadd *= k;
            }
            
            Real r,t,sinr, cosr;

            t = disc2_timespi * (px + py);
            sincos(t,&sinr,&cosr);
            r = weight * xcommon(atan) / M_PI;

            nx += (sinr + disc2_cosadd) * r;
            ny += (cosr + disc2_sinadd) * r;
            
            
    super_shape:
        param:
            super_shape_rnd: {}
            super_shape_m: {}
            super_shape_n1: 
                default: 1.0
            super_shape_n2: 
                default: 1.0
            super_shape_n3: 
                default: 1.0
            super_shape_holes: {}
        src: |-
            Real pm4 = super_shape_m / 4.0f;
            Real st, ct;
            sincos(pm4 * xcommon(phi) + M_PI/4.0f, &st, &ct);
            Real r = weight * (
                   (
                    super_shape_rnd * rs->rand_uniform() 
                    + (1.0f - super_shape_rnd) * xcommon(sqrt)
                    ) - super_shape_holes
                   ) * pow(
                    pow(abs(ct), super_shape_n2) +
                    pow(abs(st), super_shape_n3),
                    -1.0f / super_shape_n1
                   ) / xcommon(sqrt);
            nx += r * px;
            ny += r * py;
            
    flower:
        param:
            flower_holes: {}
            flower_petals: {}
        src: |-
            Real coef = weight * (rs->rand_uniform() - flower_holes) * cos(flower_petals * xcommon(atan)) / xcommon(sqrt);
            nx += coef * px;
            ny += coef * py;
    
    conic:
        param:
            conic_holes: {}
            conic_eccentricity: 
                default: 1.0
        src: |-
            Real ct = px / xcommon(sqrt);
            Real r = weight * (rs->rand_uniform() - conic_holes) *
                            conic_eccentricity / (1 + conic_eccentricity*ct) / xcommon(sqrt);
            nx += r * px;
            ny += r * py;

    parabola:
        param:
            parabola_width: {}
            parabola_height: {}
        src: |-
            Real sr, cr;
            sincos(xcommon(sqrt), &sr, &cr);
            nx += parabola_height * weight * sr * sr * rs->rand_uniform();
            ny += parabola_width * weight * cr * rs->rand_uniform();

    bent2:
        param:
            bent2_x:
                default: 1.0
            bent2_y:
                default: 1.0
        src: |-
           Real nx = px;
           Real ny = py;
           if (nx < 0.0)
              nx = nx * bent2_x;
           if (ny < 0.0)
              ny = ny * bent2_y;
           nx += weight * nx;
           ny += weight * ny;
           
    bipolar:
        param:
            bipolar_shift: {}
        src: |-
            Real x2y2 = xcommon(sumsq);
            Real t = x2y2+1;
            Real x2 = 2*px;
            Real ps = -M_PI_2 * bipolar_shift;
            Real y = 0.5 * atan2(2.0 * py, x2y2 - 1.0) + ps;
            if (y > M_PI_2)
               y = -M_PI_2 + fmod(y + M_PI_2, M_PI);
            else if (y < -M_PI_2)
               y = M_PI_2 - fmod(M_PI_2 - y, M_PI);
            nx += weight * 0.25 * M_2_PI * log ( (t+x2) / (t-x2) );
            ny += weight * M_2_PI * y;
            
    boarders: |-
        Real roundX = rint(px);
        Real roundY = rint(py);
        Real offsetX = px - roundX;
        Real offsetY = py - roundY;
        
        if(rs->rand_uniform() >= 0.75f) {
            nx += weight * (offsetX * 0.5f + roundX);
            ny += weight * (offsetY * 0.5f + roundY);
        } else {
            if(fabs(offsetX) >= fabs(offsetY)) {
                if(offsetX >= 0.0) {
                    nx += weight * (offsetX * 0.5f + roundX + 0.25f);
                    ny += weight * (offsetY * 0.5f + roundY + 0.25f * offsetY/offsetX);
                } else {
                    nx += weight * (offsetX * 0.5f + roundX - 0.25f);
                    ny += weight * (offsetY * 0.5f + roundY - 0.25f * offsetY/offsetX);                
                }
            } else {
                if(offsetY >= 0.0) {
                    ny += weight * (offsetY * 0.5f + roundY + 0.25f);
                    nx += weight * (offsetX * 0.5f + roundX + 0.25f * offsetX/offsetY);
                } else {
                    ny += weight * (offsetY * 0.5f + roundY - 0.25f);
                    nx += weight * (offsetX * 0.5f + roundX - 0.25f * offsetX/offsetY);                
                }                  
            }
        }

    butterfly: |-
        Real wx = weight*1.3029400317411197908970256609023;
        Real y2 = py*2.0;
        Real r = wx*sqrt(fabs(py * px)/(M_EPS + px*px + y2*y2));
        nx += r * px;
        ny += r * y2;
        
    cell:
        param:
            cell_size:
                default: 1.0
        src: |-
            Real inv_cell_size = 1.0/cell_size;
            /* calculate input cell */
            int x = floor(px*inv_cell_size);
            int y = floor(py*inv_cell_size);
            /* Offset from cell origin */
            Real dx = px - x*cell_size;
            Real dy = py - y*cell_size;
            /* interleave cells */
            if (y >= 0) {
              if (x >= 0) {
                 y *= 2;
                 x *= 2;
              } else {
                 y *= 2;
                 x = -(2*x+1);
              }
            } else {
              if (x >= 0) {
                 y = -(2*y+1);
                 x *= 2;
              } else {
                 y = -(2*y+1);
                 x = -(2*x+1);
              }
            }
            nx += weight * (dx + x*cell_size);
            ny -= weight * (dy + y*cell_size);
            
    cpow:
        param:
            cpow_power: 
                default: 1.0
            cpow_r:
                default: 1.0
            cpow_i: {}
        src: |-
            Real a = xcommon(phi);
            Real lnr = 0.5 * log(xcommon(sumsq));
            Real va = 2.0 * M_PI / cpow_power;
            Real vc = cpow_r / cpow_power;
            Real vd = cpow_i / cpow_power;
            Real ang = vc*a + vd*lnr + va*floor(cpow_power*rs->rand_uniform());
            Real sa,ca;
            Real m = weight * exp(vc * lnr - vd * a);
            sincos(ang,&sa,&ca);
            nx += m * ca;
            ny += m * sa;     

    curve:
        param:
            curve_xlength: 
                default: 1.0
            curve_ylength: 
                default: 1.0
            curve_xamp: {}
            curve_yamp: {}
        src: |-
            Real pc_xlen = curve_xlength*curve_xlength;
            Real pc_ylen = curve_ylength*curve_ylength;

            if (pc_xlen<1E-20) pc_xlen = 1E-20;

            if (pc_ylen<1E-20) pc_ylen = 1E-20;

            nx += weight * (px + curve_xamp * exp(-py*py/pc_xlen));
            ny += weight * (py + curve_yamp * exp(-px*px/pc_ylen));
            
    edisc: |-
        Real tmp = xcommon(sumsq) + 1.0;
        Real tmp2 = 2.0 * px;
        Real r1 = sqrt(tmp+tmp2);
        Real r2 = sqrt(tmp-tmp2);
        Real xmax = (r1+r2) * 0.5;
        Real a1 = log(xmax + sqrt(xmax - 1.0));
        Real a2 = -acos(px/xmax);
        Real w = weight / 11.57034632;
        Real snv,csv,snhu,cshu;

        sincos(a1,&snv,&csv);

        snhu = sinh(a2);
        cshu = cosh(a2);

        if (py > 0.0) snv = -snv;

        nx += w * cshu * csv;
        ny += w * snhu * snv;
        
    elliptic: |-
        Real tmp = xcommon(sumsq) + 1.0;
        Real x2 = 2.0 * px;
        Real xmax = 0.5 * (sqrt(tmp+x2) + sqrt(tmp-x2));
        Real a = px / xmax;
        Real b = 1.0 - a*a;
        Real ssx = xmax - 1.0;
        Real w = weight / M_PI_2;

        if (b<0)
          b = 0;
        else
          b = sqrt(b);

        if (ssx<0)
          ssx = 0;
        else
          ssx = sqrt(ssx);

        nx += w * atan2(a,b);

        if (py > 0)
          ny += w * log(xmax + ssx);
        else
          ny -= w * log(xmax + ssx);    
          
    escher:
        param:
            escher_beta: {}
        src: |-
            Real seb,ceb;
            Real vc,vd;
            Real m,n;
            Real sn,cn;

            Real a = xcommon(phi);
            Real lnr = 0.5 * log(xcommon(sumsq));

            sincos(escher_beta,&seb,&ceb);

            vc = 0.5 * (1.0 + ceb);
            vd = 0.5 * seb;

            m = weight * exp(vc*lnr - vd*a);
            n = vc*a + vd*lnr;

            sincos(n,&sn,&cn);

            nx += m * cn;
            ny += m * sn;        
            
    foci: |-
        Real expx = exp(px) * 0.5;
        Real expnx = 0.25 / expx;
        Real sn,cn,tmp;

        sincos(py,&sn,&cn);
        tmp = weight/(expx + expnx - cn);

        nx += tmp * (expx - expnx);
        ny += tmp * sn;    
        
    lazysusan:
        param:
            lazysusan_x: {}
            lazysusan_y: {}
            lazysusan_twist: {}
            lazysusan_spin: {}
            lazysusan_space: {}
        src: |-
            Real x = px - lazysusan_x;
            Real y = py + lazysusan_y;
            Real r = sqrt(x*x + y*y);
            Real sina, cosa;

            if (r<weight) {
              Real a = atan2(y,x) + lazysusan_spin +
                         lazysusan_twist*(weight-r);
              sincos(a,&sina,&cosa);
              r = weight * r;

              nx += r*cosa + lazysusan_x;
              ny += r*sina - lazysusan_y;
            } else {

              r = weight * (1.0 + lazysusan_space / r);

              nx += r*x + lazysusan_x;
              ny += r*y - lazysusan_y;

            }        
    
    loonie: |-
        Real r2 = xcommon(sumsq);
        Real w2 = weight*weight;

        if (r2 < w2) {
          Real r = weight * sqrt(w2/r2 - 1.0);
          nx += r * px;
          ny += r * py;
        } else {
          nx += weight * px;
          ny += weight * py;
        }
            
    modulus:
        param:
            modulus_x: {}
            modulus_y: {}
        src: |-
            Real xr = 2*modulus_x;
            Real yr = 2*modulus_y;

            if (px > modulus_x)
              nx += weight * (-modulus_x + fmod(px + modulus_x, xr));
            else if (px < -modulus_x)
              nx += weight * ( modulus_x - fmod(modulus_x - px, xr));
            else
              nx += weight * px;

            if (py > modulus_y)
              ny += weight * (-modulus_y + fmod(py + modulus_y, yr));
            else if (py < -modulus_y)
              ny += weight * ( modulus_y - fmod(modulus_y - py, yr));
            else
              ny += weight * py;
              
    oscilloscope:
        param:
            oscilloscope_frequency:
                default: 3.141592653589793238462643383279
            oscilloscope_damping: {}
            oscilloscope_amplitude: 
                default: 1.0
            oscilloscope_separation:
                default: 1.0
        src: |-
            Real tpf = 2 * M_PI * oscilloscope_frequency;
            Real t;

            if (oscilloscope_damping == 0.0)
              t = oscilloscope_amplitude * cos(tpf*px) + oscilloscope_separation;
            else {
              t = oscilloscope_amplitude * exp(-fabs(px)*oscilloscope_damping)
                  * cos(tpf*px) + oscilloscope_separation;
            }

            if (fabs(py) <= t) {
              nx += weight*px;
              ny -= weight*py;
            } else {
              nx += weight*px;
              ny += weight*py;
            }        
            
    polar2: |-
        Real p2v = weight / M_PI;

        nx += p2v * xcommon(atan);
        ny += p2v/2.0 * log(xcommon(sumsq));    
        
    popcorn2:
        param:
            popcorn2_x: {}
            popcorn2_y: {}
            popcorn2_c: {}
        src: |-
            nx += weight * ( px + popcorn2_x * sin(tan(py*popcorn2_c)));
            ny += weight * ( py + popcorn2_y * sin(tan(px*popcorn2_c)));        
            
    scry: |-
        Real t = xcommon(sumsq);
        Real r = 1.0 / (xcommon(sqrt) * (t + 1.0/(weight+M_EPS)));

        nx += px * r;
        ny += py * r;    
        
    separation:
        param:
            separation_x: {}
            separation_y: {}
            separation_xinside: {}
            separation_yinside: {}
        src: |-
            Real sx2 = separation_x * separation_x;
            Real sy2 = separation_y * separation_y;

            if (px > 0.0)
              nx += weight * (sqrt(px*px + sx2)- px*separation_xinside);
            else
              nx -= weight * (sqrt(px*px + sx2)+ px*separation_xinside);

            if (py > 0.0)
              ny += weight * (sqrt(py*py + sy2)- py*separation_yinside);
            else
              ny -= weight * (sqrt(py*py + sy2)+ py*separation_yinside);        
              
    split:
        param:
            split_xsize: {}
            split_ysize: {}
        src: |-
            if (cos(px*split_xsize*M_PI) >= 0)
              ny += weight*py;
            else
              ny -= weight*py;

            if (cos(py*split_ysize*M_PI) >= 0)
              nx += weight * px;
            else
              nx -= weight * px;        
              
    splits:
        param:
            splits_x: {}
            splits_y: {}
        src: |-
            if (px >= 0)
              nx += weight*(px+splits_x);
            else
              nx += weight*(px-splits_x);

            if (py >= 0)
              ny += weight*(py+splits_y);
            else
              ny += weight*(py-splits_y);       

    stripes:
        param:
            stripes_space: {}
            stripes_warp: {}
        src: |-
            Real roundx,offsetx;

            roundx = floor(px + 0.5);
            offsetx = px - roundx;

            nx += weight * (offsetx*(1.0-stripes_space)+roundx);
            ny += weight * (py + offsetx*offsetx*stripes_warp);  

    wedge: 
        param:
            wedge_swirl: {}
            wedge_count:
                default: 1.0
            wedge_angle: {}
            wedge_hole: {}
        src: |-
            Real r = xcommon(sqrt);
            Real a = xcommon(phi) + wedge_swirl * r;
            Real c = floor( (wedge_count * a + M_PI)*M_1_PI*0.5);

            Real comp_fac = 1 - wedge_angle*wedge_count*M_1_PI*0.5;
            Real sa, ca;

            a = a * comp_fac + c * wedge_angle;

            sincos(a,&sa,&ca);

            r = weight * (r + wedge_hole);

            nx += r*ca;
            ny += r*sa;      

    wedge_julia:
        param:
            wedge_julia_power:
                default: 1.0
            wedge_julia_angle: {}
            wedge_julia_count:
                default: 1.0
            wedge_julia_dist: {}
        src: |-
            Real wedgeJulia_cf = 1.0 - wedge_julia_angle * wedge_julia_count * M_1_PI * 0.5;
            Real wedgeJulia_rN = fabs(wedge_julia_power);
            Real wedgeJulia_cn = wedge_julia_dist / wedge_julia_power / 2.0;
            Real r = weight * pow(xcommon(sumsq), wedgeJulia_cn);
            int t_rnd = (int)((wedgeJulia_rN)*rs->rand_uniform());
            Real a = (xcommon(phi) + 2 * M_PI * t_rnd) / wedge_julia_power;
            Real c = floor( (wedge_julia_count * a + M_PI)*M_1_PI*0.5 );
            Real sa,ca;

            a = a * wedgeJulia_cf + c * wedge_julia_angle;

            sincos(a,&sa,&ca);

            nx += r * ca;
            ny += r * sa;
            
    wedge_sph:
        param:
            wedge_sph_swirl: {}
            wedge_sph_count: 
                default: 1.0
            wedge_sph_angle: {}
            wedge_sph_hole: {}
        src: |-
            Real r = 1.0/(xcommon(sqrt)+M_EPS);
            Real a = xcommon(phi) + wedge_sph_swirl * r;
            Real c = floor( (wedge_sph_count * a + M_PI)*M_1_PI*0.5);

            Real comp_fac = 1 - wedge_sph_angle*wedge_sph_count*M_1_PI*0.5;
            Real sa, ca;

            a = a * comp_fac + c * wedge_sph_angle;

            sincos(a,&sa,&ca);
            r = weight * (r + wedge_sph_hole);

            nx += r*ca;
            ny += r*sa;
            
    whorl:
        param:
            whorl_inside: {}
            whorl_outside: {}
        src: |-
            Real r = xcommon(sqrt);
            Real a,sa,ca;

            if (r<weight)
              a = xcommon(phi) + whorl_inside/(weight-r);
            else
              a = xcommon(phi) + whorl_outside/(weight-r);

            sincos(a,&sa,&ca);

            nx += weight*r*ca;
            ny += weight*r*sa;     

    waves2:
        param:
            waves2_freqx: {}
            waves2_scalex: {}
            waves2_freqy: {}
            waves2_scaley: {}
        src: |-
            nx += weight * (px + waves2_scalex * sin(py * waves2_freqx));
            ny += weight * (py + waves2_scaley * sin(px * waves2_freqy));

    exp: |-
        Real expe = exp(px);
        Real expcos,expsin;
        sincos(py,&expsin,&expcos);
        nx += weight * expe * expcos;
        ny += weight * expe * expsin;
        
    log: |-
        nx += weight * 0.5 * log(xcommon(sumsq));
        ny += weight * xcommon(phi);
        
    sin: |-
        Real sinsin,sinacos,sinsinh,sincosh;
        sincos(px,&sinsin,&sinacos);
        sinsinh = sinh(py);
        sincosh = cosh(py);
        nx += weight * sinsin * sincosh;
        ny += weight * sinacos * sinsinh;    

    cos: |-
        Real cossin,coscos,cossinh,coscosh;
        sincos(px,&cossin,&coscos);
        cossinh = sinh(py);
        coscosh = cosh(py);
        nx += weight * coscos * coscosh;
        ny -= weight * cossin * cossinh;
        
    tan: |-
        Real tansin,tancos,tansinh,tancosh;
        Real tanden;
        sincos(2*px,&tansin,&tancos);
        tansinh = sinh(2.0*py);
        tancosh = cosh(2.0*py);
        tanden = 1.0/(tancos + tancosh);
        nx += weight * tanden * tansin;
        ny += weight * tanden * tansinh;
        
    sec: |-
        Real secsin,seccos,secsinh,seccosh;
        Real secden;
        sincos(px,&secsin,&seccos);
        secsinh = sinh(py);
        seccosh = cosh(py);
        secden = 2.0/(cos(2*px) + cosh(2*py));
        nx += weight * secden * seccos * seccosh;
        ny += weight * secden * secsin * secsinh;    
    
    csc: |-
        Real cscsin,csccos,cscsinh,csccosh;
        Real cscden;
        sincos(px,&cscsin,&csccos);
        cscsinh = sinh(py);
        csccosh = cosh(py);
        cscden = 2.0/(cosh(2.0*py) - cos(2.0*px));
        nx += weight * cscden * cscsin * csccosh;
        ny -= weight * cscden * csccos * cscsinh;
        
    cot: |-
        Real cotsin,cotcos,cotsinh,cotcosh;
        Real cotden;
        sincos(2.0*px,&cotsin,&cotcos);
        cotsinh = sinh(2.0*py);
        cotcosh = cosh(2.0*py);
        cotden = 1.0/(cotcosh - cotcos);
        nx += weight * cotden * cotsin;
        ny += weight * cotden * -1 * cotsinh;    

    sinh: |-
        Real sinhsin,sinhcos,sinhsinh,sinhcosh;
        sincos(py,&sinhsin,&sinhcos);
        sinhsinh = sinh(px);
        sinhcosh = cosh(px);
        nx += weight * sinhsinh * sinhcos;
        ny += weight * sinhcosh * sinhsin;
        
    cosh: |-
        Real coshsin,coshcos,coshsinh,coshcosh;
        sincos(py,&coshsin,&coshcos);
        coshsinh = sinh(px);
        coshcosh = cosh(px);
        nx += weight * coshcosh * coshcos;
        ny += weight * coshsinh * coshsin;
        
    tanh: |-
        Real tanhsin,tanhcos,tanhsinh,tanhcosh;
        Real tanhden;
        sincos(2.0*py,&tanhsin,&tanhcos);
        tanhsinh = sinh(2.0*px);
        tanhcosh = cosh(2.0*px);
        tanhden = 1.0/(tanhcos + tanhcosh);
        nx += weight * tanhden * tanhsinh;
        ny += weight * tanhden * tanhsin;

    sech: |-
        Real sechsin,sechcos,sechsinh,sechcosh;
        Real sechden;
        sincos(py,&sechsin,&sechcos);
        sechsinh = sinh(px);
        sechcosh = cosh(px);
        sechden = 2.0/(cos(2.0*py) + cosh(2.0*px));
        nx += weight * sechden * sechcos * sechcosh;
        ny -= weight * sechden * sechsin * sechsinh;
        
    csch: |-
        Real cschsin,cschcos,cschsinh,cschcosh;
        Real cschden;
        sincos(py,&cschsin,&cschcos);
        cschsinh = sinh(px);
        cschcosh = cosh(px);
        cschden = 2.0/(cosh(2.0*px) - cos(2.0*py));
        nx += weight * cschden * cschsinh * cschcos;
        ny -= weight * cschden * cschcosh * cschsin;    

    coth: |-
        Real cothsin,cothcos,cothsinh,cothcosh;
        Real cothden;
        sincos(2.0*py,&cothsin,&cothcos);
        cothsinh = sinh(2.0*px);
        cothcosh = cosh(2.0*px);
        cothden = 1.0/(cothcosh - cothcos);
        nx += weight * cothden * cothsinh;
        ny += weight * cothden * cothsin;

    auger: 
        param:
            auger_freq:
                default: 1.0
            auger_weight: {}
            auger_scale:
                default: 1.0
            auger_sym: {}
        src: |-
            Real s = sin(auger_freq * px);
            Real t = sin(auger_freq * py);
            Real dy = py + auger_weight*(auger_scale*s/2.0 + fabs(py)*s);
            Real dx = px + auger_weight*(auger_scale*t/2.0 + fabs(px)*t);

            nx += weight * (px + auger_sym*(dx-px));
            ny += weight * dy;        
    
    flux:
        param:
            flux_spread: {}
        src: |-
            Real xpw = px + weight;
            Real xmw = px - weight;
            Real avgr = weight * (2 + flux_spread) * sqrt( sqrt(py*py + xpw*xpw) / sqrt(py*py + xmw*xmw));
            Real avga = ( atan2(py, xmw) - atan2(py,xpw) ) * 0.5;

            nx += avgr * cos(avga);
            ny += avgr * sin(avga);        

    mobius:
        param:
            mobius_re_a: {}
            mobius_im_a: {}
            mobius_re_b: {}
            mobius_im_b: {}
            mobius_re_c: {}
            mobius_im_c: {}
            mobius_re_d: {}
            mobius_im_d: {}            
        src: |-
            Real re_u, im_u, re_v, im_v, rad_v;

            re_u = mobius_re_a * px - mobius_im_a * py + mobius_re_b;
            im_u = mobius_re_a * py + mobius_im_a * px + mobius_im_b;
            re_v = mobius_re_c * px - mobius_im_c * py + mobius_re_d;
            im_v = mobius_re_c * py + mobius_im_c * px + mobius_im_d;

            rad_v = weight / (re_v*re_v + im_v*im_v);

            nx += rad_v * (re_u*re_v + im_u*im_v);
            ny += rad_v * (im_u*re_v - re_u*im_v);        


       




            

            

            







        

           

           
