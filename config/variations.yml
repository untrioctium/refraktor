# Variation definitions
# Code in this file is adapted from flam3 by Scott Draves and others
# https://github.com/scottdraves/flam3/blob/master/variations.c

xcommon:
    sumsq: px * px + py * py
    sqrt: hypot(px, py)
    atan: atan2(px, py)
    phi: atan2(py, px)
    sina: px / xcommon(sqrt)
    cosa: py / xcommon(sqrt)
    sinr: ::sin(xcommon(sqrt))
    cosr: ::cos(xcommon(sqrt))
    
variations:
    linear: |-
        nx += weight * px;
        ny += weight * py;

    sinusoidal: |-
        nx += weight * ::sin(px);
        ny += weight * ::sin(py);
        
    spherical: |-
        FloatT r2 = weight / ( xcommon(sumsq) + M_EPS);
        nx += r2 * px;
        ny += r2 * py;
        
    swirl: |-
        FloatT c1 = ::sin(xcommon(sumsq));
        FloatT c2 = ::cos(xcommon(sumsq));
        nx += weight * (c1 * px - c2 * py);
        ny += weight * (c2 * px + c1 * py);
        
    horseshoe: |-
        weight /= (xcommon(sqrt) + M_EPS);
        nx += weight * (px + py) * (px - py);
        ny += weight * 2.0_r * px * py;
        
    polar: |-
        nx += weight * xcommon(atan) / M_PI;
        ny += weight * (xcommon(sqrt) - 1.0_r);
        
    handkerchief: |-
        weight *= xcommon(sqrt);
        nx += weight * ::sin(xcommon(atan) + xcommon(sqrt));
        ny += weight * ::cos(xcommon(atan) - xcommon(sqrt));
        
    heart: |-
        FloatT a = xcommon(sqrt) * xcommon(atan);
        FloatT ca,sa;
        FloatT r = weight * xcommon(sqrt);

        sincos(a,&sa,&ca);

        nx += r * sa;
        ny += (-r) * ca;

    disc: |-
        FloatT a = xcommon(atan) * M_1_PI;
        FloatT r = M_PI * xcommon(sqrt);
        FloatT sr,cr;
        sincos(r,&sr,&cr);

        nx += weight * sr * a;
        ny += weight * cr * a;
        
    spiral: |-
        FloatT r = xcommon(sqrt) + M_EPS;
        FloatT coef = weight / r;
        FloatT sr, cr;
        sincos(r, &sr, &cr);
        nx += coef * (xcommon(cosa) + sr);
        ny += coef * (xcommon(sina) - cr);
        
    hyperbolic: |-
        FloatT coeff = xcommon(sqrt) + M_EPS;
        nx += weight * xcommon(sina) / coeff;
        ny += weight * xcommon(cosa) * coeff;
        
    diamond: |-
        FloatT sr,cr;
        sincos( xcommon(sqrt), &sr, &cr);
        nx += weight * xcommon(sina) * cr;
        ny += weight * xcommon(cosa) * sr;
        
    ex: |-
        FloatT n0 = ::sin(xcommon(atan) + xcommon(sqrt));
        FloatT n1 = ::cos(xcommon(atan) - xcommon(sqrt));
        FloatT m0 = n0 * n0 * n0 * xcommon(sqrt);
        FloatT m1 = n1 * n1 * n1 * xcommon(sqrt);
        nx += weight * (m0 + m1);
        ny += weight * (m0 - m1);

    julia: |-
        FloatT r;
        FloatT a = 0.5_r * xcommon(atan);
        FloatT sa,ca;

        a += M_PI * ((rs->rand() >> 24) & 1);

        r = weight * sqrt(xcommon(sqrt));

        sincos(a,&sa,&ca);

        nx += r * ca;
        ny += r * sa;
        
    bent: |-
        FloatT bx = px;
        FloatT by = py;
        if(bx < 0.0_r) bx *= 2.0_r;
        if(by < 0.0_r) by /= 2.0_r;
        nx += weight * bx;
        ny += weight * by;
        
    waves:
        param:
            waves_dx2:
                is_precalc: true
            waves_dy2:
                is_precalc: true
        precalc: |-
            waves_dx2 = 1.0_r/(xaffine_c * xaffine_c + M_EPS);
            waves_dy2 = 1.0_r/(xaffine_f * xaffine_f + M_EPS);
        src: |-
            nx += weight * (px + xaffine_b * ::sin( py * waves_dx2));
            ny += weight * (py + xaffine_e * ::sin( px * waves_dy2));
        
    fisheye: |-
        weight *= 2 / (xcommon(sqrt) + 1);
        nx += weight * py;
        ny += weight * px;
    
    popcorn: |-
        nx += weight * (px + xaffine_c * ::sin(tan(3 * py)));
        ny += weight * (py + xaffine_f * ::sin(tan(3 * px)));
        
    exponential: |-
        FloatT dx = weight * ::exp(px - 1.0_r);
        FloatT sdy, cdy;
        sincos( M_PI * py, &sdy, &cdy );
        nx += dx * cdy;
        ny += dx * sdy;
        
    power: |-
        FloatT coef = weight * pow(xcommon(sqrt), xcommon(sina));
        nx += coef * xcommon(cosa);
        ny += coef * xcommon(sina);
        
    cosine: |-
        FloatT sa, ca;
        sincos( px * M_PI, &sa, &ca );
        nx += weight * (ca * ::cosh(py));
        ny += weight * (-sa * ::sinh(py));
        
    rings: |-
        FloatT dx = xaffine_c * xaffine_c + M_EPS;
        weight *= (fmod(xcommon(sqrt) + dx, 2 * dx) - dx + xcommon(sqrt) * (1 - dx));
        nx += weight * xcommon(cosa);
        ny += weight * xcommon(sina);
        
    fan: |-
        FloatT dx = M_PI * (xaffine_c * xaffine_c + M_EPS);
        FloatT dx2 = 0.5_r * dx;
        FloatT a = xcommon(atan);
        weight *= xcommon(sqrt);
        FloatT sa, ca;
        a += (fmod(a + xaffine_f, dx) > dx2) ? -dx2: dx2;
        __sincos(a, &sa, &ca);
        nx += weight * ca;
        ny += weight * sa;

    blob:
        param:
            blob_low: {}
            blob_high: 
                default: 1.0
            blob_waves: 
                default: 1.0
        src: |-
            FloatT bdiff = blob_high - blob_low;
            weight *= xcommon(sqrt) * (blob_low + bdiff * (0.5_r + 0.5_r * ::sin(blob_waves * xcommon(atan))));
            nx += weight * xcommon(sina);
            ny += weight * xcommon(cosa);

    pdj:
        param:
            pdj_a: {}
            pdj_b: {}
            pdj_c: {}
            pdj_d: {}
        src: |-
            nx += weight * (::sin(pdj_a * py) - ::cos(pdj_b * px));
            ny += weight * (::sin(pdj_c * px) - ::cos(pdj_d * py));
            
    fan2:
        param:
            fan2_x: {}
            fan2_y: {}
        src: |-
            FloatT dy = fan2_y;
            FloatT dx = M_PI * (fan2_x * fan2_x + M_EPS);
            FloatT dx2 = 0.5_r * dx;
            FloatT a = xcommon(atan);
            FloatT sa,ca;
            FloatT r = weight * xcommon(sqrt);
            FloatT t = a + dy - dx * (int)((a + dy)/dx);
            if (t>dx2)
               a = a-dx2;
            else
               a = a+dx2;
            sincos(a,&sa,&ca);
            nx += r * sa;
            ny += r * ca;

    rings2: 
        param:
            rings2_val: {}
        src: |-
            FloatT r = xcommon(sqrt);
            FloatT dx = rings2_val * rings2_val + M_EPS;
            r += -2.0_r * dx * (int)((r+dx)/(2.0_r * dx)) + r * (1.0_r-dx);
            nx += weight * xcommon(sina) * r;
            ny += weight * xcommon(cosa) * r;
            
    eyefish: |-
        FloatT coef = 2 * weight / (xcommon(sqrt) + 1);
        nx += coef * px;
        ny += coef * py;

    bubble: |-
        FloatT coef = weight / (0.25_r * xcommon(sumsq) + 1);
        nx += coef * px;
        ny += coef * py;

    cylinder: |-
        nx += weight * ::sin(px);
        ny += weight * py;      

    perspective:
        param:
            perspective_angle: {}
            perspective_dist: {}
            perspective_vsin:
                is_precalc: true
            perspective_vfcos:
                is_precalc: true
        precalc: |-
            sincos(perspective_angle * M_PI/ 2.0_r, &perspective_vsin, &perspective_vfcos);
            perspective_vfcos *= perspective_dist;            
        src: |-
            FloatT t= 1.0_r / (perspective_dist - py * perspective_vsin);
            nx += weight * perspective_dist * px * t;
            ny += weight * perspective_vfcos * py * t;

    noise: |-
        FloatT sr, cr, r;
        sincos(rs->rand_uniform() * 2.0_r * M_PI, &sr, &cr);
        r = weight * rs->rand_uniform();
        nx += px * r * sr;
        ny += py * r * cr;

    julian:
        param:
            julian_dist: 
                default: 1.0
            julian_power: 
                default: 1.0
            julian_rN:
                is_precalc: true
            julian_cn:
                is_precalc: true
        precalc: |-
            julian_rN = abs(julian_power);
            julian_cn = julian_dist / julian_power / 2.0_r;
        src: |-
            int t_rnd = trunc(julian_rN * rs->rand_uniform());
            FloatT tmpr = (xcommon(phi) + 2 * M_PI * t_rnd) / julian_power;
            FloatT r = weight * __pow(xcommon(sumsq), julian_cn);
            FloatT sa, ca;
            __sincos(tmpr, &sa, &ca);
            nx += r * ca;
            ny += r * sa; 

    juliascope:
        param:
            juliascope_dist: 
                default: 1.0
            juliascope_power: 
                default: 1.0
            juliascope_rN:
                is_precalc: true
            juliascope_cn:
                is_precalc: true
        precalc: |-
            juliascope_rN = abs(juliascope_power);
            juliascope_cn = juliascope_dist / juliascope_power;
        src: |-
            int t_rnd = trunc(juliascope_rN * rs->rand_uniform());
            FloatT tmpr, r;
            FloatT sa,ca;
            if((t_rnd & 1) == 0)
                tmpr = (2 * M_PI * t_rnd + xcommon(phi)) / juliascope_power;
            else
                tmpr = (2 * M_PI * t_rnd - xcommon(phi)) / juliascope_power;
            sincos(tmpr, &sa, &ca);
            r = weight * pow(xcommon(sqrt), juliascope_cn);
            nx += r * ca;
            ny += r * sa;

    blur: |-
        FloatT r, sinang,cosang;
        sincos( rs->rand_uniform() * 2 * M_PI, &sinang, &cosang );
        r = weight * rs->rand_uniform(); 
        nx += r * cosang;
        ny += r * sinang;  

    gaussian_blur: |-
        auto gauss = rs->rand_gaussian(weight);
        nx += gauss.x;
        ny += gauss.y;     

    radial_blur:
        param:
            radial_blur_angle: {}
            radial_blur_spinvar: 
                is_precalc: true
            radial_blur_zoomvar: 
                is_precalc: true
        precalc: |-
                sincos(radial_blur_angle * M_PI / 2.0_r, &radial_blur_spinvar, &radial_blur_zoomvar);
        src: |-
            FloatT rnd_g, rz, tmpa, sa, ca;
            rnd_g = weight *(rs->rand_uniform() + rs->rand_uniform() +rs->rand_uniform() +rs->rand_uniform() - 2.0_r);
            tmpa = xcommon(phi) + radial_blur_spinvar * rnd_g;
            sincos(tmpa, &sa, &ca);
            rz = radial_blur_zoomvar * rnd_g - 1;
            nx += xcommon(sqrt) * ca + rz * px;
            ny += xcommon(sqrt) * sa + rz * py;     

    pie:
        param:
            pie_thickness: {}
            pie_rotation: {}
            pie_slices: 
                default: 6.0
        src: |-
            FloatT a, r, sa, ca;
            int sl;
            sl = (int) (rs->rand_uniform() * pie_slices + 0.5_r);
            a = pie_rotation + 2.0_r * M_PI * (sl + rs->rand_uniform() * pie_thickness)/pie_slices;
            r = weight * rs->rand_uniform();
            sincos(a, &sa, &ca);
            nx += r * ca;
            ny += r * sa;

    ngon:
        param:
            ngon_power: {}
            ngon_sides: {}
            ngon_circle: {}
            ngon_corners: {}
        src: |-
            FloatT r_factor,theta,phi,b, amp;
            r_factor = pow(xcommon(sumsq), ngon_power/2.0_r);
            theta = xcommon(phi);
            b = 2*M_PI/ngon_sides;
            phi = theta - (b*floor(theta/b));
            if (phi > b/2)
                phi -= b;
            amp = ngon_corners * (1.0_r / (::cos(phi) + M_EPS) - 1.0_r) + ngon_circle;
            amp /= (r_factor + M_EPS);
            nx += weight * px * amp;
            ny += weight * py * amp;
     
    curl:
        param:
            curl_c1: 
                default: 1.0
            curl_c2: {}
        src: |-
            FloatT re = 1.0_r + curl_c1 * px + curl_c2 * (px * px - py * py);
            FloatT im = curl_c1 * py + 2.0_r * curl_c2 * px * py;
            FloatT r = weight / (re * re + im * im);
            nx += (px * re + py * im) * r;
            ny += (py * re - px * im) * r;

    rectangles:
        param:
            rectangles_x: 
                default: 1.0
            rectangles_y: 
                default: 1.0
        src: |-
            if(rectangles_x == 0.0_r)
                nx += weight * px;
            else
                nx += weight * ((2 * floor(px / rectangles_x) + 1) * rectangles_x - px);
            if(rectangles_y == 0.0_r)
                ny += weight * py;
            else
                ny += weight * ((2 * floor(py / rectangles_y) + 1) * rectangles_y - py);

    arch: |-
        FloatT ang = rs->rand_uniform() * weight * M_PI;
        FloatT sinr,cosr;
        sincos(ang,&sinr,&cosr);

        nx += weight * sinr;
        ny += weight * (sinr*sinr)/cosr;
        
    tangent: |-
        nx += weight * ::sin(px)/::cos(py);
        ny += weight * tan(py);
        
    square: |-
        nx += weight * (rs->rand_uniform() - 0.5_r);
        ny += weight * (rs->rand_uniform() - 0.5_r);
        
    rays: |-
        FloatT ang = weight * rs->rand_uniform() * M_PI;
        FloatT r = weight / (xcommon(sumsq) + M_EPS);
        FloatT tanr = weight * tan(ang) * r;
        nx += tanr * ::cos(px);
        ny += tanr * ::sin(py);
        
    blade: |-
        FloatT r = rs->rand_uniform() * weight * xcommon(sqrt);
        FloatT sinr,cosr;
        sincos(r,&sinr,&cosr);
        nx += weight * px * (cosr + sinr);
        ny += weight * px * (cosr - sinr);
        
    secant2: |-
        FloatT r = weight * xcommon(sqrt);
        FloatT cr = ::cos(r);
        FloatT icr = 1.0_r/cr;
        nx += weight * px;
        if (cr<0)
          ny += weight*(icr + 1);
        else
          ny += weight*(icr - 1);
          
    twintrian:
        FloatT r = rs->rand_uniform() * weight * xcommon(sqrt);
        FloatT sinr,cosr,diff;
        sincos(r,&sinr,&cosr);
        diff = log10(sinr*sinr)+cosr;
        if (badvalue(diff))
            diff = -30.0_r;
        nx += weight * px * diff;
        ny += weight * px * (diff - sinr*M_PI);
        
    cross: |-
        FloatT s = px * px - py * py;
        weight *= sqrt(1.0_r/(s * s + M_EPS));
        nx += px * weight;
        ny += py * weight;

    disc2:
        param:
            disc2_rot: {}
            disc2_twist: {}
            disc2_sinadd:
                is_precalc: true
            disc2_cosadd:
                is_precalc: true
            disc2_timespi:
                is_precalc: true
        precalc: |-
            FloatT add = disc2_twist;
            FloatT k, disc2_timespi, disc2_sinadd, disc2_cosadd;

            disc2_timespi = disc2_rot * M_PI;

            sincos(add,&disc2_sinadd,&disc2_cosadd);
            disc2_cosadd -= 1;

            if (add > 2 * M_PI) {
              k = (1 + add - 2*M_PI);
              disc2_cosadd *= k;
              disc2_sinadd *= k;
            }

            if (add < -2 * M_PI) {
              k = (1 + add + 2*M_PI);
              disc2_cosadd *= k;
              disc2_sinadd *= k;
            }

        src: |-
            FloatT r,t,sinr, cosr;

            t = disc2_timespi * (px + py);
            sincos(t,&sinr,&cosr);
            r = weight * xcommon(atan) / M_PI;

            nx += (sinr + disc2_cosadd) * r;
            ny += (cosr + disc2_sinadd) * r;
            
            
    super_shape:
        param:
            super_shape_rnd: {}
            super_shape_m: {}
            super_shape_n1: 
                default: 1.0
            super_shape_n2: 
                default: 1.0
            super_shape_n3: 
                default: 1.0
            super_shape_holes: {}
            super_shape_pm_4:
                is_precalc: true
            super_shape_pneg1_n1:
                is_precalc: true
        precalc: |-
            super_shape_pm_4 = super_shape_m / 4.0_r;
            super_shape_pneg1_n1 = -1.0_r/super_shape_n1;
        src: |-
            FloatT st, ct;
            sincos(super_shape_pm_4 * xcommon(phi) + M_PI/4.0_r, &st, &ct);
            FloatT r = weight * (
                   (
                    super_shape_rnd * rs->rand_uniform() 
                    + (1.0_r - super_shape_rnd) * xcommon(sqrt)
                    ) - super_shape_holes
                   ) * pow(
                    pow(abs(ct), super_shape_n2) +
                    pow(abs(st), super_shape_n3),
                    super_shape_pneg1_n1
                   ) / xcommon(sqrt);
            nx += r * px;
            ny += r * py;
            
    flower:
        param:
            flower_holes: {}
            flower_petals: {}
        src: |-
            FloatT coef = weight * (rs->rand_uniform() - flower_holes) * ::cos(flower_petals * xcommon(atan)) / xcommon(sqrt);
            nx += coef * px;
            ny += coef * py;
    
    conic:
        param:
            conic_holes: {}
            conic_eccentricity: 
                default: 1.0
        src: |-
            FloatT ct = px / xcommon(sqrt);
            FloatT r = weight * (rs->rand_uniform() - conic_holes) *
                            conic_eccentricity / (1 + conic_eccentricity*ct) / xcommon(sqrt);
            nx += r * px;
            ny += r * py;

    parabola:
        param:
            parabola_width: {}
            parabola_height: {}
        src: |-
            FloatT sr, cr;
            sincos(xcommon(sqrt), &sr, &cr);
            nx += parabola_height * weight * sr * sr * rs->rand_uniform();
            ny += parabola_width * weight * cr * rs->rand_uniform();

    bent2:
        param:
            bent2_x:
                default: 1.0
            bent2_y:
                default: 1.0
        src: |-
           FloatT bx = px;
           FloatT by = py;
           if (bx < 0.0_r)
              bx = bx * bent2_x;
           if (by < 0.0_r)
              by = by * bent2_y;
           nx += weight * bx;
           ny += weight * by;
           
    bipolar:
        param:
            bipolar_shift: {}
        src: |-
            FloatT x2y2 = xcommon(sumsq);
            FloatT t = x2y2+1;
            FloatT x2 = 2*px;
            FloatT ps = -M_PI_2 * bipolar_shift;
            FloatT y = 0.5_r * atan2(2.0_r * py, x2y2 - 1.0_r) + ps;
            if (y > M_PI_2)
               y = -M_PI_2 + fmod(y + M_PI_2, M_PI);
            else if (y < -M_PI_2)
               y = M_PI_2 - fmod(M_PI_2 - y, M_PI);
            nx += weight * 0.25_r * M_2_PI * log ( (t+x2) / (t-x2) );
            ny += weight * M_2_PI * y;
            
    boarders: |-
        FloatT roundX = rint(px);
        FloatT roundY = rint(py);
        FloatT offsetX = px - roundX;
        FloatT offsetY = py - roundY;
        
        if(rs->rand_uniform() >= 0.75_r) {
            nx += weight * (offsetX * 0.5_r + roundX);
            ny += weight * (offsetY * 0.5_r + roundY);
        } else {
            if(fabs(offsetX) >= fabs(offsetY)) {
                if(offsetX >= 0.0_r) {
                    nx += weight * (offsetX * 0.5_r + roundX + 0.25_r);
                    ny += weight * (offsetY * 0.5_r + roundY + 0.25_r * offsetY/offsetX);
                } else {
                    nx += weight * (offsetX * 0.5_r + roundX - 0.25_r);
                    ny += weight * (offsetY * 0.5_r + roundY - 0.25_r * offsetY/offsetX);                
                }
            } else {
                if(offsetY >= 0.0_r) {
                    ny += weight * (offsetY * 0.5_r + roundY + 0.25_r);
                    nx += weight * (offsetX * 0.5_r + roundX + 0.25_r * offsetX/offsetY);
                } else {
                    ny += weight * (offsetY * 0.5_r + roundY - 0.25_r);
                    nx += weight * (offsetX * 0.5_r + roundX - 0.25_r * offsetX/offsetY);                
                }                  
            }
        }

    butterfly: |-
        FloatT wx = weight*1.3029400317411197908970256609023_r;
        FloatT y2 = py*2.0_r;
        FloatT r = wx*sqrt(fabs(py * px)/(M_EPS + px*px + y2*y2));
        nx += r * px;
        ny += r * y2;
        
    cell:
        param:
            cell_size:
                default: 1.0
        src: |-
            FloatT inv_cell_size = 1.0_r/cell_size;
            /* calculate input cell */
            int x = floor(px*inv_cell_size);
            int y = floor(py*inv_cell_size);
            /* Offset from cell origin */
            FloatT dx = px - x*cell_size;
            FloatT dy = py - y*cell_size;
            /* interleave cells */
            if (y >= 0) {
              if (x >= 0) {
                 y *= 2;
                 x *= 2;
              } else {
                 y *= 2;
                 x = -(2*x+1);
              }
            } else {
              if (x >= 0) {
                 y = -(2*y+1);
                 x *= 2;
              } else {
                 y = -(2*y+1);
                 x = -(2*x+1);
              }
            }
            nx += weight * (dx + x*cell_size);
            ny -= weight * (dy + y*cell_size);
            
    cpow:
        param:
            cpow_power: 
                default: 1.0
            cpow_r:
                default: 1.0
            cpow_i: {}
        src: |-
            FloatT a = xcommon(phi);
            FloatT lnr = 0.5_r * ::log(xcommon(sumsq));
            FloatT va = 2.0_r * M_PI / cpow_power;
            FloatT vc = cpow_r / cpow_power;
            FloatT vd = cpow_i / cpow_power;
            FloatT ang = vc*a + vd*lnr + va*floor(cpow_power*rs->rand_uniform());
            FloatT sa,ca;
            FloatT m = weight * ::exp(vc * lnr - vd * a);
            sincos(ang,&sa,&ca);
            nx += m * ca;
            ny += m * sa;     

    curve:
        param:
            curve_xlength: 
                default: 1.0
            curve_ylength: 
                default: 1.0
            curve_xamp: {}
            curve_yamp: {}
        src: |-
            FloatT pc_xlen = curve_xlength*curve_xlength;
            FloatT pc_ylen = curve_ylength*curve_ylength;

            if (pc_xlen<1E-20) pc_xlen = 1E-20;

            if (pc_ylen<1E-20) pc_ylen = 1E-20;

            nx += weight * (px + curve_xamp * ::exp(-py*py/pc_xlen));
            ny += weight * (py + curve_yamp * ::exp(-px*px/pc_ylen));
            
    edisc: |-
        FloatT tmp = xcommon(sumsq) + 1.0_r;
        FloatT tmp2 = 2.0_r * px;
        FloatT r1 = sqrt(tmp+tmp2);
        FloatT r2 = sqrt(tmp-tmp2);
        FloatT xmax = (r1+r2) * 0.5_r;
        FloatT a1 = ::log(xmax + sqrt(xmax - 1.0_r));
        FloatT a2 = -acos(px/xmax);
        FloatT w = weight / 11.57034632_r;
        FloatT snv,csv,snhu,cshu;

        sincos(a1,&snv,&csv);

        snhu = ::sinh(a2);
        cshu = ::cosh(a2);

        if (py > 0.0_r) snv = -snv;

        nx += w * cshu * csv;
        ny += w * snhu * snv;
        
    elliptic: |-
        FloatT tmp = xcommon(sumsq) + 1.0_r;
        FloatT x2 = 2.0_r * px;
        FloatT xmax = 0.5_r * (sqrt(tmp+x2) + sqrt(tmp-x2));
        FloatT a = px / xmax;
        FloatT b = 1.0_r - a*a;
        FloatT ssx = xmax - 1.0_r;
        FloatT w = weight / M_PI_2;

        if (b<0)
          b = 0;
        else
          b = sqrt(b);

        if (ssx<0)
          ssx = 0;
        else
          ssx = sqrt(ssx);

        nx += w * atan2(a,b);

        if (py > 0)
          ny += w * ::log(xmax + ssx);
        else
          ny -= w * ::log(xmax + ssx);    
          
    escher:
        param:
            escher_beta: {}
        src: |-
            FloatT seb,ceb;
            FloatT vc,vd;
            FloatT m,n;
            FloatT sn,cn;

            FloatT a = xcommon(phi);
            FloatT lnr = 0.5_r * ::log(xcommon(sumsq));

            sincos(escher_beta,&seb,&ceb);

            vc = 0.5_r * (1.0_r + ceb);
            vd = 0.5_r * seb;

            m = weight * ::exp(vc*lnr - vd*a);
            n = vc*a + vd*lnr;

            sincos(n,&sn,&cn);

            nx += m * cn;
            ny += m * sn;        
            
    foci: |-
        FloatT expx = ::exp(px) * 0.5_r;
        FloatT expnx = 0.25_r / expx;
        FloatT sn,cn,tmp;

        sincos(py,&sn,&cn);
        tmp = weight/(expx + expnx - cn);

        nx += tmp * (expx - expnx);
        ny += tmp * sn;    
        
    lazysusan:
        param:
            lazysusan_x: {}
            lazysusan_y: {}
            lazysusan_twist: {}
            lazysusan_spin: {}
            lazysusan_space: {}
        src: |-
            FloatT x = px - lazysusan_x;
            FloatT y = py + lazysusan_y;
            FloatT r = sqrt(x*x + y*y);
            FloatT sina, cosa;

            if (r<weight) {
              FloatT a = atan2(y,x) + lazysusan_spin +
                         lazysusan_twist*(weight-r);
              sincos(a,&sina,&cosa);
              r = weight * r;

              nx += r*cosa + lazysusan_x;
              ny += r*sina - lazysusan_y;
            } else {

              r = weight * (1.0_r + lazysusan_space / r);

              nx += r*x + lazysusan_x;
              ny += r*y - lazysusan_y;

            }        
    
    loonie: |-
        FloatT r2 = xcommon(sumsq);
        FloatT w2 = weight*weight;

        if (r2 < w2) {
          FloatT r = weight * sqrt(w2/r2 - 1.0_r);
          nx += r * px;
          ny += r * py;
        } else {
          nx += weight * px;
          ny += weight * py;
        }
            
    modulus:
        param:
            modulus_x: {}
            modulus_y: {}
        src: |-
            FloatT xr = 2*modulus_x;
            FloatT yr = 2*modulus_y;

            if (px > modulus_x)
              nx += weight * (-modulus_x + fmod(px + modulus_x, xr));
            else if (px < -modulus_x)
              nx += weight * ( modulus_x - fmod(modulus_x - px, xr));
            else
              nx += weight * px;

            if (py > modulus_y)
              ny += weight * (-modulus_y + fmod(py + modulus_y, yr));
            else if (py < -modulus_y)
              ny += weight * ( modulus_y - fmod(modulus_y - py, yr));
            else
              ny += weight * py;
              
    oscilloscope:
        param:
            oscilloscope_frequency:
                default: 3.141592653589793238462643383279
            oscilloscope_damping: {}
            oscilloscope_amplitude: 
                default: 1.0
            oscilloscope_separation:
                default: 1.0
        src: |-
            FloatT tpf = 2 * M_PI * oscilloscope_frequency;
            FloatT t;

            if (oscilloscope_damping == 0.0_r)
              t = oscilloscope_amplitude * ::cos(tpf*px) + oscilloscope_separation;
            else {
              t = oscilloscope_amplitude * ::exp(-fabs(px)*oscilloscope_damping)
                  * ::cos(tpf*px) + oscilloscope_separation;
            }

            if (fabs(py) <= t) {
              nx += weight*px;
              ny -= weight*py;
            } else {
              nx += weight*px;
              ny += weight*py;
            }        
            
    polar2: |-
        FloatT p2v = weight / M_PI;

        nx += p2v * xcommon(atan);
        ny += p2v/2.0_r * ::log(xcommon(sumsq));    
        
    popcorn2:
        param:
            popcorn2_x: {}
            popcorn2_y: {}
            popcorn2_c: {}
        src: |-
            nx += weight * ( px + popcorn2_x * ::sin(tan(py*popcorn2_c)));
            ny += weight * ( py + popcorn2_y * ::sin(tan(px*popcorn2_c)));        
            
    scry: |-
        FloatT t = xcommon(sumsq);
        FloatT r = 1.0_r / (xcommon(sqrt) * (t + 1.0_r/(weight+M_EPS)));

        nx += px * r;
        ny += py * r;    
        
    separation:
        param:
            separation_x: {}
            separation_y: {}
            separation_xinside: {}
            separation_yinside: {}
        src: |-
            FloatT sx2 = separation_x * separation_x;
            FloatT sy2 = separation_y * separation_y;

            if (px > 0.0_r)
              nx += weight * (sqrt(px*px + sx2)- px*separation_xinside);
            else
              nx -= weight * (sqrt(px*px + sx2)+ px*separation_xinside);

            if (py > 0.0_r)
              ny += weight * (sqrt(py*py + sy2)- py*separation_yinside);
            else
              ny -= weight * (sqrt(py*py + sy2)+ py*separation_yinside);        
              
    split:
        param:
            split_xsize: {}
            split_ysize: {}
        src: |-
            if (::cos(px*split_xsize*M_PI) >= 0)
              ny += weight*py;
            else
              ny -= weight*py;

            if (::cos(py*split_ysize*M_PI) >= 0)
              nx += weight * px;
            else
              nx -= weight * px;        
              
    splits:
        param:
            splits_x: {}
            splits_y: {}
        src: |-
            if (px >= 0)
              nx += weight*(px+splits_x);
            else
              nx += weight*(px-splits_x);

            if (py >= 0)
              ny += weight*(py+splits_y);
            else
              ny += weight*(py-splits_y);       

    stripes:
        param:
            stripes_space: {}
            stripes_warp: {}
        src: |-
            FloatT roundx,offsetx;

            roundx = floor(px + 0.5_r);
            offsetx = px - roundx;

            nx += weight * (offsetx*(1.0_r-stripes_space)+roundx);
            ny += weight * (py + offsetx*offsetx*stripes_warp);  

    wedge: 
        param:
            wedge_swirl: {}
            wedge_count:
                default: 1.0
            wedge_angle: {}
            wedge_hole: {}
        src: |-
            FloatT r = xcommon(sqrt);
            FloatT a = xcommon(phi) + wedge_swirl * r;
            FloatT c = floor( (wedge_count * a + M_PI)*M_1_PI*0.5_r);

            FloatT comp_fac = 1 - wedge_angle*wedge_count*M_1_PI*0.5_r;
            FloatT sa, ca;

            a = a * comp_fac + c * wedge_angle;

            sincos(a,&sa,&ca);

            r = weight * (r + wedge_hole);

            nx += r*ca;
            ny += r*sa;      

    wedge_julia:
        param:
            wedge_julia_power:
                default: 1.0
            wedge_julia_angle: {}
            wedge_julia_count:
                default: 1.0
            wedge_julia_dist: {}
            wedge_julia_cf:
                is_precalc: true
            wedge_julia_rN:
                is_precalc: true
            wedge_julia_cn:
                is_precalc: true
        precalc: |-
            wedge_julia_cf = 1.0_r - wedge_julia_angle * wedge_julia_count * M_1_PI * 0.5_r;
            wedge_julia_rN = fabs(wedge_julia_power);
            wedge_julia_cn = wedge_julia_dist / wedge_julia_power / 2.0_r;
        src: |-
            FloatT r = weight * pow(xcommon(sumsq), wedge_julia_cn);
            int t_rnd = (int)((wedge_julia_rN)*rs->rand_uniform());
            FloatT a = (xcommon(phi) + 2 * M_PI * t_rnd) / wedge_julia_power;
            FloatT c = floor( (wedge_julia_count * a + M_PI)*M_1_PI*0.5_r );
            FloatT sa,ca;

            a = a * wedge_julia_cf + c * wedge_julia_angle;

            sincos(a,&sa,&ca);

            nx += r * ca;
            ny += r * sa;
            
    wedge_sph:
        param:
            wedge_sph_swirl: {}
            wedge_sph_count: 
                default: 1.0
            wedge_sph_angle: {}
            wedge_sph_hole: {}
        src: |-
            FloatT r = 1.0_r/(xcommon(sqrt)+M_EPS);
            FloatT a = xcommon(phi) + wedge_sph_swirl * r;
            FloatT c = floor( (wedge_sph_count * a + M_PI)*M_1_PI*0.5_r);

            FloatT comp_fac = 1 - wedge_sph_angle*wedge_sph_count*M_1_PI*0.5_r;
            FloatT sa, ca;

            a = a * comp_fac + c * wedge_sph_angle;

            sincos(a,&sa,&ca);
            r = weight * (r + wedge_sph_hole);

            nx += r*ca;
            ny += r*sa;
            
    whorl:
        param:
            whorl_inside: {}
            whorl_outside: {}
        src: |-
            FloatT r = xcommon(sqrt);
            FloatT a,sa,ca;

            if (r<weight)
              a = xcommon(phi) + whorl_inside/(weight-r);
            else
              a = xcommon(phi) + whorl_outside/(weight-r);

            sincos(a,&sa,&ca);

            nx += weight*r*ca;
            ny += weight*r*sa;     

    waves2:
        param:
            waves2_freqx: {}
            waves2_scalex: {}
            waves2_freqy: {}
            waves2_scaley: {}
        src: |-
            nx += weight * (px + waves2_scalex * ::sin(py * waves2_freqx));
            ny += weight * (py + waves2_scaley * ::sin(px * waves2_freqy));

    exp: |-
        FloatT expe = ::exp(px);
        FloatT expcos,expsin;
        sincos(py,&expsin,&expcos);
        nx += weight * expe * expcos;
        ny += weight * expe * expsin;
        
    log: |-
        nx += weight * 0.5_r * ::log(xcommon(sumsq));
        ny += weight * xcommon(phi);
        
    sin: |-
        FloatT sinsin,sinacos,sinsinh,sincosh;
        sincos(px,&sinsin,&sinacos);
        sinsinh = ::sinh(py);
        sincosh = ::cosh(py);
        nx += weight * sinsin * sincosh;
        ny += weight * sinacos * sinsinh;    

    cos: |-
        FloatT cossin,coscos,cossinh,coscosh;
        sincos(px,&cossin,&coscos);
        cossinh = ::sinh(py);
        coscosh = ::cosh(py);
        nx += weight * coscos * coscosh;
        ny -= weight * cossin * cossinh;
        
    tan: |-
        FloatT tansin,tancos,tansinh,tancosh;
        FloatT tanden;
        sincos(2*px,&tansin,&tancos);
        tansinh = ::sinh(2.0_r*py);
        tancosh = ::cosh(2.0_r*py);
        tanden = 1.0_r/(tancos + tancosh);
        nx += weight * tanden * tansin;
        ny += weight * tanden * tansinh;
        
    sec: |-
        FloatT secsin,seccos,secsinh,seccosh;
        FloatT secden;
        sincos(px,&secsin,&seccos);
        secsinh = ::sinh(py);
        seccosh = ::cosh(py);
        secden = 2.0_r/(::cos(2*px) + ::cosh(2*py));
        nx += weight * secden * seccos * seccosh;
        ny += weight * secden * secsin * secsinh;    
    
    csc: |-
        FloatT cscsin,csccos,cscsinh,csccosh;
        FloatT cscden;
        sincos(px,&cscsin,&csccos);
        cscsinh = ::sinh(py);
        csccosh = ::cosh(py);
        cscden = 2.0_r/(::cosh(2.0_r*py) - ::cos(2.0_r*px));
        nx += weight * cscden * cscsin * csccosh;
        ny -= weight * cscden * csccos * cscsinh;
        
    cot: |-
        FloatT cotsin,cotcos,cotsinh,cotcosh;
        FloatT cotden;
        sincos(2.0_r*px,&cotsin,&cotcos);
        cotsinh = ::sinh(2.0_r*py);
        cotcosh = ::cosh(2.0_r*py);
        cotden = 1.0_r/(cotcosh - cotcos);
        nx += weight * cotden * cotsin;
        ny += weight * cotden * -1 * cotsinh;    

    sinh: |-
        FloatT sinhsin,sinhcos,sinhsinh,sinhcosh;
        sincos(py,&sinhsin,&sinhcos);
        sinhsinh = ::sinh(px);
        sinhcosh = ::cosh(px);
        nx += weight * sinhsinh * sinhcos;
        ny += weight * sinhcosh * sinhsin;
        
    cosh: |-
        FloatT coshsin,coshcos,coshsinh,coshcosh;
        sincos(py,&coshsin,&coshcos);
        coshsinh = ::sinh(px);
        coshcosh = ::cosh(px);
        nx += weight * coshcosh * coshcos;
        ny += weight * coshsinh * coshsin;
        
    tanh: |-
        FloatT tanhsin,tanhcos,tanhsinh,tanhcosh;
        FloatT tanhden;
        sincos(2.0_r*py,&tanhsin,&tanhcos);
        tanhsinh = ::sinh(2.0_r*px);
        tanhcosh = ::cosh(2.0_r*px);
        tanhden = 1.0_r/(tanhcos + tanhcosh);
        nx += weight * tanhden * tanhsinh;
        ny += weight * tanhden * tanhsin;

    sech: |-
        FloatT sechsin,sechcos,sechsinh,sechcosh;
        FloatT sechden;
        sincos(py,&sechsin,&sechcos);
        sechsinh = ::sinh(px);
        sechcosh = ::cosh(px);
        sechden = 2.0_r/(::cos(2.0_r*py) + ::cosh(2.0_r*px));
        nx += weight * sechden * sechcos * sechcosh;
        ny -= weight * sechden * sechsin * sechsinh;
        
    csch: |-
        FloatT cschsin,cschcos,cschsinh,cschcosh;
        FloatT cschden;
        sincos(py,&cschsin,&cschcos);
        cschsinh = ::sinh(px);
        cschcosh = ::cosh(px);
        cschden = 2.0_r/(::cosh(2.0_r*px) - ::cos(2.0_r*py));
        nx += weight * cschden * cschsinh * cschcos;
        ny -= weight * cschden * cschcosh * cschsin;    

    coth: |-
        FloatT cothsin,cothcos,cothsinh,cothcosh;
        FloatT cothden;
        sincos(2.0_r*py,&cothsin,&cothcos);
        cothsinh = ::sinh(2.0_r*px);
        cothcosh = ::cosh(2.0_r*px);
        cothden = 1.0_r/(cothcosh - cothcos);
        nx += weight * cothden * cothsinh;
        ny += weight * cothden * cothsin;

    auger: 
        param:
            auger_freq:
                default: 1.0
            auger_weight: {}
            auger_scale:
                default: 1.0
            auger_sym: {}
        src: |-
            FloatT s = ::sin(auger_freq * px);
            FloatT t = ::sin(auger_freq * py);
            FloatT dy = py + auger_weight*(auger_scale*s/2.0_r + fabs(py)*s);
            FloatT dx = px + auger_weight*(auger_scale*t/2.0_r + fabs(px)*t);

            nx += weight * (px + auger_sym*(dx-px));
            ny += weight * dy;        
    
    flux:
        param:
            flux_spread: {}
        src: |-
            FloatT xpw = px + weight;
            FloatT xmw = px - weight;
            FloatT avgr = weight * (2 + flux_spread) * sqrt( sqrt(py*py + xpw*xpw) / sqrt(py*py + xmw*xmw));
            FloatT avga = ( atan2(py, xmw) - atan2(py,xpw) ) * 0.5_r;

            nx += avgr * ::cos(avga);
            ny += avgr * ::sin(avga);        

    mobius:
        param:
            mobius_re_a: {}
            mobius_im_a: {}
            mobius_re_b: {}
            mobius_im_b: {}
            mobius_re_c: {}
            mobius_im_c: {}
            mobius_re_d: {}
            mobius_im_d: {}            
        src: |-
            FloatT re_u, im_u, re_v, im_v, rad_v;

            re_u = mobius_re_a * px - mobius_im_a * py + mobius_re_b;
            im_u = mobius_re_a * py + mobius_im_a * px + mobius_im_b;
            re_v = mobius_re_c * px - mobius_im_c * py + mobius_re_d;
            im_v = mobius_re_c * py + mobius_im_c * px + mobius_im_d;

            rad_v = weight / (re_v*re_v + im_v*im_v);

            nx += rad_v * (re_u*re_v + im_u*im_v);
            ny += rad_v * (im_u*re_v - re_u*im_v);        

    bwraps:
        param:
            bwraps_cellsize: {default: 1.0}
            bwraps_space: {}
            bwraps_gain: {default: 1.0}
            bwraps_inner_twist: {}
            bwraps_outer_twist: {}
            bwraps_g2: {is_precalc: true}
            bwraps_r2: {is_precalc: true}
            bwraps_rfactor: {is_precalc: true}
        precalc: |-
            FloatT radius = 0.5_r * (bwraps_cellsize / (1.0_r + bwraps_space * bwraps_space));
            bwraps_g2 = bwraps_gain * bwraps_gain + 1.0e-6_r;
            FloatT max_bubble = bwraps_g2 * radius;
            if(max_bubble > 2) max_bubble = 1;
            else max_bubble *= (1 / (max_bubble * max_bubble / 4 + 1));
            bwraps_r2 = eps(radius * radius);
            bwraps_rfactor = radius / max_bubble;
        src: |-
            if(bwraps_cellsize == 0.0) {
                nx += weight * px;
                ny += weight * py;
            } else {
                FloatT vx = px;
                FloatT vy = py;
                FloatT cx = (floor(vx / bwraps_cellsize) + 0.5_r) * bwraps_cellsize;
                FloatT cy = (floor(vy / bwraps_cellsize) + 0.5_r) * bwraps_cellsize;
                FloatT lx = vx - cx;
                FloatT ly = vy - cy;

                if(lx * lx + ly * ly > bwraps_r2) {
                    nx += weight * px;
                    ny += weight * py;
                } else {
                    lx *= bwraps_g2;
                    ly *= bwraps_g2;

                    FloatT r= bwraps_rfactor / eps(fma(lx, lx, ly * ly)/ 4 + 1);
                    lx *= r;
                    ly *= r;
                    r = fma(lx, lx, ly * ly) / bwraps_r2;

                    FloatT theta = fma(bwraps_inner_twist, 1 - r, bwraps_outer_twist * r);
                    FloatT s, c;
                    sincos(theta, &s, &c);

                    vx = fma(s, ly, fma(c, lx, cx));
                    vy = cy - s * lx + c * ly;
                    nx += weight * vx;
                    ny += weight * vy;
                }
            }
       




            

            

            







        

           

           
