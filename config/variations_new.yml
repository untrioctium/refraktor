linear: result += weight * p;

sinusoidal: result += weight * sin(p);

spherical: result += weight / eps(common.sumsq) * p;

swirl: |-
  scsum := sincos(common.sumsq);
  result.x += weight * (scsum.x * p.x - scsum.y * p.y);
  result.y += weight * (scsum.y * p.x + scsum.x * p.y);

horseshoe: result += weight / eps(common.sqrt) * vec2((p.x + p.y) * (p.x - p.y), 2.0 * p.x * p.y);

polar: result += weight * vec2(common.atan / math.pi, common.sqrt - 1.0);

handkerchief: result += weight * common.sqrt * vec2(sin(common.atan + common.sqrt), cos(common.atan - common.sqrt));

heart: |-
  sca := sincos(common.sqrt * common.atan);
  r := weight * common.sqrt;
  result.x += r * sca.x;
  result.y -= r * sca.y;

disc: result += weight * common.atan * math.inv_pi * sincos(math.pi * common.sqrt);

spiral: |-
  r := eps(common.sqrt);
  scr := sincos(r);
  result += weight / r * vec2(common.cosa + scr.x, common.sina - scr.y);

hyperbolic: |-
  coeff := eps(common.sqrt);
  result.x += weight * common.sina / coeff;
  result.y += weight * common.cosa * coeff;

diamond: |-
  scr := sincos(common.sqrt);
  result.x += weight * common.sina * scr.y;
  result.y += weight * common.cosa * scr.x;

ex: |-
  n0 := sin(common.atan + common.sqrt);
  n1 := cos(common.atan - common.sqrt);
  m0 := n0 * n0 * n0 * common.sqrt;
  m1 := n1 * n1 * n1 * common.sqrt;
  result.x += weight * (m0 + m1);
  result.y += weight * (m0 - m1);

julia: result += weight * sqrt(common.sqrt) * cossin(0.5 * common.atan + math.pi * randbit());

bent: |-
  b := p;
  if(b.x < 0.0) b.x *= 2;
  if(b.y < 0.0) b.y /= 2;
  result += weight * b;

waves:
  param:
    dx2:
      tags: [precalc]
    dy2:
      tags: [precalc]
  precalc: |-
    param.dx2 = 1/eps(aff.c * aff.c);
    param.dy2 = 1/eps(aff.f * aff.f);
  src: |-
    result.x += weight * (p.x + aff.b * sin(p.y * param.dx2));
    result.y += weight * (p.y + aff.e * sin(p.x * param.dy2));

fisheye: result += 2 * weight / (common.sqrt + 1) * vec2(p.y, p.x);

popcorn: |-
  result.x += weight * (p.x + aff.c * sin(tan(3 * p.y)));
  result.y += weight * (p.y + aff.f * sin(tan(3 * p.x)));

exponential: result += weight * exp(p.x - 1) * cossinpi(p.y);

power: result += weight * pow(common.sqrt, common.sina) * vec2(common.cosa, common.sina);

cosine: |-
  sca := sincospi(p.x);
  result.x += weight * sca.y * cosh(p.y);
  result.y += weight * -sca.x * sinh(p.y);

rings: |-
  dx := eps(aff.c * aff.c);
  result += weight * (modf(common.sqrt + dx, 2 * dx) - dx + common.sqrt * (1 - dx)) * vec2(common.cosa, common.sina);

fan: |-
  dx := math.pi * eps(aff.c * aff.c);
  dx2 := 0.5 * dx;
  a := common.atan;

  a += copysign(dx2, dx2 - modf(a + aff.f, dx));
  result += weight * common.sqrt * cossin(a);

blob:
  param:
    low: {}
    high: {default: 1.0}
    waves: {default: 1.0}
  src: result += weight * common.sqrt * (param.low + (param.high - param.low) * (0.5 + 0.5 * sin(param.waves * common.atan))) * vec2(common.sina, common.cosa);

pdj:
  param:
    a: {}
    b: {}
    c: {}
    d: {}
  src: |-
    result.x += weight * (sin(param.a * p.y) - cos(param.b * p.x));
    result.y += weight * (sin(param.c * p.x) - cos(param.d * p.y));

fan2:
  param:
    x: {}
    y: {}
  src: |-
    dy := param.y;
    dx := math.pi * eps(param.x * param.x);
    dx2 := 0.5 * dx;
    a := common.atan;
    r := weight * common.sqrt;
    t := a + dy - dx * floor((a + dy)/dx);
    if(t > dx2)
      a -= dx2;
    else
      a += dx2;

    result += r * sincos(a);

rings2:
  param:
    val: {}
  src: |-
    r := common.sqrt;
    dx := eps(param.val * param.val);
    r += 2.0 * dx * floor((r+dx)/(2.0 * dx)) + r * (1.0 - dx);
    result.x += weight * common.sina * r;
    result.y += weight * common.cosa * r;

eyefish: result += 2 * weight / (common.sqrt + 1) * p;

bubble: result += weight / (0.25 * common.sumsq + 1) * p;

cylinder: |-
  result.x += weight * sin(p.x);
  result.y += weight * p.y;

perspective:
  param:
    angle: {}
    dist: {}
    vsin: {tags: [precalc]}
    vfcos: {tags: [precalc]}
  precalc: |-
    sc := sincospi(param.angle/2);
    param.vsin = sc.x;
    param.vfcos = sc.y * param.dist;
  src: |-
    t := 1.0 / (param.dist - p.y * param.vsin);
    result.x += weight * param.dist * p.x * t;
    result.y += weight * param.vfcos * p.y * t;

noise: result += weight * rand01() * elmul(p, cossinpi(rand01() * 2));

julian:
  param:
    dist: {default: 1.0}
    power: {default: 1.0}
    rN: {tags: [precalc]}
    cn: {tags: [precalc]}
  precalc: |-
    param.rN = abs(param.power);
    param.cn = param.dist / param.power / 2.0;
  src: |-
    t_rnd := trunc(param.rN * rand01());
    tmpr := (common.phi + 2 * math.pi * t_rnd)/param.power;
    r := weight * pow(common.sumsq, param.cn);
    result += r * cossin(tmpr);

juliascope:
  param:
    dist: {default: 1.0}
    power: {default: 1.0}
    rN: {tags: [precalc]}
    cn: {tags: [precalc]}
  precalc: |-
    param.rN = abs(param.power);
    param.cn = param.dist / param.power;
  src: |-
    t_rnd := trunc(param.rN * rand01());
    tmpr := 2 * math.pi * t_rnd;
    if(is_even(t_rnd)) {
      tmpr += common.phi;
    } else {
      tmpr -= common.phi;
    }
    tmpr /= param.power;
    result += weight * pow(common.sqrt, param.cn) * cossin(tmpr);

blur: |-
  result += weight * rand01() * cossinpi(rand01() * 2);

gaussian_blur: result += randgauss();

radial_blur:
  param:
    angle: {}
    spinvar: {tags: [precalc]}
    zoomvar: {tags: [precalc]}
  precalc: |-
    sca := sincospi(param.angle / 2);
    param.spinvar = sca.x;
    param.zoomvar = sca.y;
  src: |-
    rnd_g := weight * (rand01() + rand01() + rand01() + rand01() - 2);
    sca := sincos(common.phi + param.spinvar * rnd_g);
    rz := param.zoomvar * rnd_g - 1;
    result.x += common.sqrt * sca.y + rz * p.x;
    result.y += common.sqrt * sca.x + rz * p.y;

pie:
  param:
    thickness: {}
    rotation: {}
    slices: {default: 6.0}
  src: |-
    sl := trunc(rand01() * param.slices + 0.5);
    a := param.rotation + 2.0 * math.pi * (sl + rand01() *  param.thickness)/param.slices;
    result += weight * rand01() * cossin(a);

ngon:
  param:
    power: {}
    sides: {}
    circle: {}
    corners: {}
  src: |-
    r_factor := pow(common.sumsq, param.power/2);
    theta := common.phi;
    b := 2 * math.pi / param.sides;
    phi := theta - b * floor(theta / b);
    if( phi > b/2) phi -= b;
    amp := param.corners * (1/eps(cos(phi)) - 1) + param.circle;
    amp /= eps(r_factor);
    result += weight * p * amp;

curl:
  param:
    c1: {default: 1.0}
    c2: {}
  src: |-
    re := 1.0 + param.c1 * p.x + param.c2 * (p.x * p.x - p.y * p.y);
    im := param.c1 * p.y + 2.0 * param.c2 * p.x * p.y;
    r := weight / (re * re * im * im);
    result.x += (p.x * re + p.y * im) * r;
    result.y += (p.y * re - p.x * im) * r;

rectangles:
  param:
    x: {default: 1.0}
    y: {default: 1.0}
  src: |-
    if(param.x == 0.0)
      result.x += weight * p.x;
    else
      result.x += weight * ((2.0 * floor(p.x / param.x) + 1.0) * param.x - p.x);
    if(param.y == 0.0)
      result.y += weight * p.y;
    else
      result.y += weight * ((2.0 * floor(p.y / param.y) + 1.0) * param.y - p.y);

arch: |-
  sca := sincospi(rand01() * weight);
  result.x += weight * sca.x;
  result.y += weight * (sca.x * sca.x)/sca.y;

tangent: |-
  result.x += weight * (sin(p.x)/cos(p.y));
  result.y += weight * tan(p.y);

square: |-
  result.x += weight * (rand01() - 0.5);
  result.y += weight * (rand01() - 0.5);

rays: |-
  ang := weight * rand01() * math.pi;
  r := weight / eps(common.sumsq);
  tanr := weight * tan(ang) * r;
  result.x += tanr * cos(p.x);
  result.y += tanr * sin(p.y);

blade: |-
  r := rand01() * weight * common.sqrt;
  scr := sincos(r);
  result.x += weight * p.x * (scr.y + scr.x);
  result.y += weight * p.x * (scr.y - scr.x);

secant2: |-
  r := weight * common.sqrt;
  cr := cos(r);
  icr := 1/cr;
  result.x += weight * p.x;
  if(cr<0)
    result.y += weight * (icr + 1);
  else
    result.y += weight * (icr - 1);

twintrian: |-
  r := rand01() * weight * common.sqrt;
  scr := sincos(r);
  diff := log10(eps(scr.x * scr.x)) + scr.y;
  result.x += weight * p.x * diff;
  result.y += weight * p.x * (diff - scr.x * math.pi);

cross: |-
  s := p.x * p.x - p.y * p.y;
  result += weight * sqrt(1/eps(s * s)) * p;