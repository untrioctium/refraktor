#ifndef EZRTC_STD_TYPE_TRAITS
#define EZRTC_STD_TYPE_TRAITS

namespace std {
    
    template<class T, T v>
    struct integral_constant {
        static constexpr T value = v;
        using value_type = T;
        using type = integral_constant; // using injected-class-name
        constexpr operator value_type() const noexcept { return value; }
        constexpr value_type operator()() const noexcept { return value; } // since c++14
    };

    template<bool V>
    using bool_constant = std::integral_constant<bool, V>;

    using true_type = std::bool_constant<true>;
    using false_type = std::bool_constant<false>;

    template<bool B, class T, class F>
    struct conditional { using type = T; };
    
    template<class T, class F>
    struct conditional<false, T, F> { using type = F; };

    template<class T, class U> struct is_same : std::false_type {};
    template<class T> struct is_same<T, T> : std::true_type {};

    template<class T> struct is_pointer : std::false_type {};
    template<class T> struct is_pointer<T*> : std::true_type {};
    template<class T> struct is_pointer<T* const> : std::true_type {};
    template<class T> struct is_pointer<T* volatile> : std::true_type {};
    template<class T> struct is_pointer<T* const volatile> : std::true_type {};

    template<class T> struct is_volatile             : std::false_type {};
    template<class T> struct is_volatile<volatile T> : std::true_type {};

    template< class T > struct remove_cv                   { typedef T type; };
    template< class T > struct remove_cv<const T>          { typedef T type; };
    template< class T > struct remove_cv<volatile T>       { typedef T type; };
    template< class T > struct remove_cv<const volatile T> { typedef T type; };
    
    template< class T > struct remove_const                { typedef T type; };
    template< class T > struct remove_const<const T>       { typedef T type; };
    
    template< class T > struct remove_volatile             { typedef T type; };
    template< class T > struct remove_volatile<volatile T> { typedef T type; };

    template< class T >
    struct is_floating_point
        : std::integral_constant<
            bool,
            // Note: standard floating-point types
            std::is_same<float, typename std::remove_cv<T>::type>::value
            || std::is_same<double, typename std::remove_cv<T>::type>::value
            || std::is_same<long double, typename std::remove_cv<T>::type>::value
        > {};

    // Note: this implementation uses C++20 facilities
    template< class T >
    struct is_integral : std::bool_constant<
        requires (T t, T* p, void (*f)(T)) // T* parameter excludes reference types
        {
            reinterpret_cast<T>(t); // Exclude class types
            f(0); // Exclude enumeration types
            p + t; // Exclude everything not yet excluded but integral types
        }> {};

    

    template< class T >
    struct is_arithmetic : std::integral_constant<bool,
                                                std::is_integral<T>::value ||
                                                std::is_floating_point<T>::value> {};

    namespace detail {
        template<typename T,bool = std::is_arithmetic<T>::value>
        struct is_signed : std::integral_constant<bool, T(-1) < T(0)> {};
        
        template<typename T>
        struct is_signed<T,false> : std::false_type {};
    } // namespace detail
    
    template<typename T>
    struct is_signed : detail::is_signed<T>::type {};

    template<bool B, class T = void>
    struct enable_if {};
    
    template<class T>
    struct enable_if<true, T> { typedef T type; };

    using size_t = ::size_t;
}

#endif